<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fwdpp: pfix.cc</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">pfix.cc</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  \include pfix.cc</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  Estimate fixation probability under single-site model with additivity.  P(fix) should be \approx 2s for small s.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  This simulation is equvalent to the following R code:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  pfixWF=function(N,s,nreps)</span></div>
<div class="line"><span class="comment">  {</span></div>
<div class="line"><span class="comment">    nfixed=0</span></div>
<div class="line"><span class="comment">    for( i in 1:nreps )</span></div>
<div class="line"><span class="comment">      {</span></div>
<div class="line"><span class="comment">        q=1/(2*N)</span></div>
<div class="line"><span class="comment">        while(q&gt;0&amp;&amp;q&lt;1)</span></div>
<div class="line"><span class="comment">        {</span></div>
<div class="line"><span class="comment">          p = 1-q</span></div>
<div class="line"><span class="comment">          wbar = p^2 + 2*p*q*(1+s) + (1+2*s)*q^2</span></div>
<div class="line"><span class="comment">          Eqprime = q + p*q*s/wbar</span></div>
<div class="line"><span class="comment">          q = rbinom(1,2*N,Eqprime)/(2*N)</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        if(q==1)</span></div>
<div class="line"><span class="comment">          {</span></div>
<div class="line"><span class="comment">            nfixed=nfixed+1</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    return(nfixed/nreps)</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  However, this simulation will be SLOWER than the R code because it is doing a lot more each generation.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/df8/diploid_8hh.html">fwdpp/diploid.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  typedefs simplify life.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  These use containers from namespace std.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  Containers from boost are often faster </span></div>
<div class="line"><span class="comment">  and use the same syntax, but we&#39;ll keep</span></div>
<div class="line"><span class="comment">  things &quot;std&quot; in this example.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  Use the basic mutation type from fwdpp,</span></div>
<div class="line"><span class="comment">  including s and h as selection coefficient</span></div>
<div class="line"><span class="comment">  and dominance</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keyword">typedef</span> <a name="_a0"></a><a class="code" href="../../d1/d7f/structKTfwd_1_1mutation.html">KTfwd::mutation</a> mtype;</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  Store mutations in doubly-linked list</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keyword">typedef</span> std::list&lt;mtype&gt; mlist;</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  Gametes container iterators derived from mlist,</span></div>
<div class="line"><span class="comment">  so they need to know our mutation type.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> <a name="_a1"></a><a class="code" href="../../d6/d90/structKTfwd_1_1gamete__base.html">KTfwd::gamete_base&lt;mtype,mlist&gt;</a> gtype;</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  glist is our doubly-linked list of gametes</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> std::list&lt;gtype&gt; glist;</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  Finally, dipvec is a vector of pairs of iterators</span></div>
<div class="line"><span class="comment">  derived from our glist</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt; std::pair&lt;glist::iterator,</div>
<div class="line">                               glist::iterator&gt; &gt; dipvec;</div>
<div class="line"></div>
<div class="line"><span class="comment">//The relevant namespaces</span></div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span>KTfwd;</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  This example has a mutation rate of 0. </span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  However, a mutation policy MUST</span></div>
<div class="line"><span class="comment">  return a mutation object.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  This policy&#39;s operator() returns</span></div>
<div class="line"><span class="comment">  a mutation at position 0, s = 0,</span></div>
<div class="line"><span class="comment">  count = 1, and dominance = 1.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">struct </span>no_mutation</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> mtype result_type;</div>
<div class="line">  <span class="comment">//A pointer to a list of mutations MUST be passed to the mutation model</span></div>
<div class="line">  <span class="keyword">inline</span> mtype operator()(mlist * mutations)<span class="keyword">const </span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    abort();<span class="comment">//must never be called!</span></div>
<div class="line">    <span class="keywordflow">return</span> mtype(0,0,1,1);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">  This example has no recombination.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  However, fwdpp requires a genetic map</span></div>
<div class="line"><span class="comment">  policy that returns a double, representing</span></div>
<div class="line"><span class="comment">  the position of an xover event.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  This is that policy for this sim.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">struct </span>no_recombination</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">inline</span> <span class="keywordtype">double</span> operator()(<span class="keywordtype">void</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    abort();<span class="comment">//this function must never be called!</span></div>
<div class="line">    <span class="keywordflow">return</span> 0.;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ( argc != 5)</div>
<div class="line">    {</div>
<div class="line">      cerr &lt;&lt; <span class="stringliteral">&quot;Too few arguments.\n&quot;</span></div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;Usage: pfix N s nreps seed\n&quot;</span>;</div>
<div class="line">      exit(10);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordtype">int</span> argument=1;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> N = atoi(argv[argument++]);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> s = atof(argv[argument++]);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nreps = atoi(argv[argument++]);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> seed = atoi(argv[argument++]);</div>
<div class="line"></div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">    fwdpp uses GSL&#39;s random number generation scheme.</span></div>
<div class="line"><span class="comment">    See the following for documentation:</span></div>
<div class="line"><span class="comment">    http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Generation.html#Random-Number-Generation</span></div>
<div class="line"><span class="comment">    http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html#Random-Number-Distributions</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Requires -lgsl -lgslcblas at link time.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Note: In C, an additional -lm would be required AFTER linking the GSL librarys.  However, the -lm</span></div>
<div class="line"><span class="comment">    is implicit in C++ because the standard C++ library requires the math library.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  gsl_rng * r =  gsl_rng_alloc(gsl_rng_ranlxs2);</div>
<div class="line">  gsl_rng_set(r,seed);</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Now, we cound the number of fixations in the next nreps simulations</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> fixations = 0,rep=0;</div>
<div class="line">  <span class="keywordflow">while</span>( rep++ &lt; nreps )</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">//Create an empty mutation list</span></div>
<div class="line">      mlist mutations;</div>
<div class="line">      <span class="comment">//The population begins with 1 gamete and 2N copies of that gamete</span></div>
<div class="line">      glist gametes(1,gtype(2*N));</div>
<div class="line"></div>
<div class="line">      <span class="comment">//The population begins with N diploids.  Each diploid contains two copies of the initial gamete</span></div>
<div class="line">      dipvec diploids(N,make_pair(gametes.begin(),gametes.begin()));</div>
<div class="line"></div>
<div class="line">      <span class="comment">/*</span></div>
<div class="line"><span class="comment">        The next several operations give some insight into what the internals of the library are doing.</span></div>
<div class="line"><span class="comment">        Typically, we&#39;d pick a gamete, decide how many mutations it gets, then apply mutation model that</span></div>
<div class="line"><span class="comment">        many times to the gamete, etc.  Instead, we will manually add our selected mutation to a </span></div>
<div class="line"><span class="comment">        randomly-chosen gamete.</span></div>
<div class="line"><span class="comment">      */</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">/*</span></div>
<div class="line"><span class="comment">        Manually add a selected mutation to population at position 0.5 and dominance of 1.</span></div>
<div class="line"><span class="comment">       The return value of an insert into a linked list is an iterator recording the position</span></div>
<div class="line"><span class="comment">       in the list of where the insertion took place.  We need that info.</span></div>
<div class="line"><span class="comment">      */</span></div>
<div class="line">      mlist::iterator mitr = mutations.insert(mutations.end(),</div>
<div class="line">                                              <a class="code" href="../../d1/d7f/structKTfwd_1_1mutation.html">mutation</a>(0.5,s,1,1.));</div>
<div class="line">      <span class="comment">//make a new gamete containing this new mutation</span></div>
<div class="line">      gtype mutant(1);</div>
<div class="line"></div>
<div class="line">      <span class="comment">//The mutation is selected, so we add it to the selected mutations container of our new gamete</span></div>
<div class="line">      mutant.smutations.push_back(mitr);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="comment">//make a random gamete the mutant.  Pick individual first, then gamete</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> ind = unsigned(gsl_ran_flat(r,0.,<span class="keywordtype">double</span>(N)));</div>
<div class="line">      <span class="keywordtype">unsigned</span> gam = (gsl_rng_uniform(r)&lt;=0.5) ? 0 : 1;</div>
<div class="line">      <span class="keywordflow">if</span>(!gam)</div>
<div class="line">        {</div>
<div class="line">          diploids[ind].first = gametes.insert(gametes.end(),mutant);</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          diploids[ind].second = gametes.insert(gametes.end(),mutant);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      <span class="comment">//We&#39;re now beyond the part where we are doing &quot;internal&quot; operations manually.</span></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">while</span>(mitr-&gt;n &gt; 0 &amp;&amp; mitr-&gt;n &lt; 2*N)<span class="comment">//While our mutation is still segregating...</span></div>
<div class="line">        {</div>
<div class="line">          <span class="comment">//...we sample the next generation.</span></div>
<div class="line"></div>
<div class="line">          <span class="comment">/*</span></div>
<div class="line"><span class="comment">            sample_diploid is the main function for individual-based simulations.</span></div>
<div class="line"><span class="comment">          */</span></div>
<div class="line">          <a name="a2"></a><a class="code" href="../../da/d8b/namespaceKTfwd.html#a946efaa4a6095f4f2aadda44a809a477">sample_diploid</a>(r,</div>
<div class="line">                         &amp;gametes,</div>
<div class="line">                         &amp;diploids,</div>
<div class="line">                         &amp;mutations,</div>
<div class="line">                         N,                                                         <span class="comment">//If we wished pop. size to change, we&#39;d pass N,N2 here.  For models where N in next generation changes over time, N2 would be updated accordingly each generation at the end of this block.</span></div>
<div class="line">                         0.,                                                        <span class="comment">//mutation rate = 0.</span></div>
<div class="line">                         std::bind( no_mutation(),std::placeholders::_1 ),                           <span class="comment">//Our mutation model.  The _1 is a placeholder for a pointer to the list of mutations.</span></div>
<div class="line">                         std::bind(<a name="_a3"></a><a class="code" href="../../d1/d5b/structKTfwd_1_1genetics101.html">KTfwd::genetics101</a>(),std::placeholders::_1,std::placeholders::_2,                    <span class="comment">//genetics101 is the basic model of crossing over in fwdpp.  If you want different models, write a replacement policy.  _1 and _2 are place holders for the two gametes that will recombine.</span></div>
<div class="line">                                     &amp;gametes,</div>
<div class="line">                                     0.,                                            <span class="comment">//The rec. rate is 0</span></div>
<div class="line">                                     r,</div>
<div class="line">                                     no_recombination()),                           <span class="comment">//This is our genetic map</span></div>
<div class="line">                         std::bind(KTfwd::insert_at_end&lt;mtype,mlist&gt;,std::placeholders::_1,std::placeholders::_2),      <span class="comment">//This policy defines how new mutations are added to the mlist.  They are inserted at the end.  This will never be called (as mut. rate = 0), but it is required.</span></div>
<div class="line">                         std::bind(KTfwd::insert_at_end&lt;gtype,glist&gt;,std::placeholders::_1,std::placeholders::_2),      <span class="comment">//This policy defines how new gametes are added to the glist.  They are inserted at the end.  This will never be called (no mutation nor recombination), but it is required.</span></div>
<div class="line">                         std::bind(<a name="_a4"></a><a class="code" href="../../dd/de5/structKTfwd_1_1multiplicative__diploid.html">KTfwd::multiplicative_diploid</a>(),std::placeholders::_1,std::placeholders::_2,2.),     <span class="comment">//The fitness model.  Fitnesses are 1, 1+hs, 1+scaling*s per site, and multiplicative over sites.  Scaling = 2 and h = 1 (as used here) gives 1, 1+s, 1+2s, which is genic selection.</span></div>
<div class="line">                         std::bind(<a name="_a5"></a><a class="code" href="../../d4/de8/structKTfwd_1_1mutation__remover.html">KTfwd::mutation_remover</a>(),std::placeholders::_1,0,2*N));          <span class="comment">//A mutation that hits a count of either 0 or 2N is removed from a gamete.</span></div>
<div class="line"></div>
<div class="line">          <span class="comment">/*</span></div>
<div class="line"><span class="comment">            Typically, for a &quot;pop-gen&quot; simulation where relative fitness is all that matters,</span></div>
<div class="line"><span class="comment">            after sampling the daughter generation, we would want to remove </span></div>
<div class="line"><span class="comment">            fixed/lost mutations from the mlist via a call to remove_fixed_lost.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">            However, this is one of those simultations where we don&#39;t want to do that</span></div>
<div class="line"><span class="comment">            b/c we want to know the final fate fo the mutation.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">            Another example of where we would not want to remove fixed mutations would</span></div>
<div class="line"><span class="comment">            be for quantitative trait sims and/or sims involving evolution to new phenotypic</span></div>
<div class="line"><span class="comment">            optimum. In those cases, fixed mutations affect trait values and should be kept around.</span></div>
<div class="line"><span class="comment">           */</span></div>
<div class="line">        }</div>
<div class="line">      <span class="comment">//increment our fixations counter</span></div>
<div class="line">      fixations += (mitr-&gt;n == 2*N) ? 1 : 0;</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">//Write fixation probability to STDOUT</span></div>
<div class="line">  cout &lt;&lt; double(fixations)/double(nreps) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
