<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fwdpp: KTfwd Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.2.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">KTfwd Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The primary namespace defined by this library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:de/dbd/namespaceKTfwd_1_1fwdpp__internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dbd/namespaceKTfwd_1_1fwdpp__internal.html">fwdpp_internal</a></td></tr>
<tr class="memdesc:de/dbd/namespaceKTfwd_1_1fwdpp__internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested namespace for nuts and bolts of certain library functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0b/structKTfwd_1_1no__selection.html">no_selection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fitness of 1.  <a href="../../dc/d0b/structKTfwd_1_1no__selection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ddb/structKTfwd_1_1site__dependent__fitness.html">site_dependent_fitness</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d99/structKTfwd_1_1haplotype__dependent__fitness.html">haplotype_dependent_fitness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for fitness as a function of the two haplotypes in a diploid.  <a href="../../de/d99/structKTfwd_1_1haplotype__dependent__fitness.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de5/structKTfwd_1_1multiplicative__diploid.html">multiplicative_diploid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplicative fitness across sites.  <a href="../../dd/de5/structKTfwd_1_1multiplicative__diploid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structKTfwd_1_1additive__diploid.html">additive_diploid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive fitness across sites.  <a href="../../d6/d39/structKTfwd_1_1additive__diploid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da4/structKTfwd_1_1mutation__base.html">mutation_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for mutations At minimum, a mutation must contain a position and a count in the population. You can derive from this class, for instance to add selection coefficients, counts in different sexes, etc.  <a href="../../d1/da4/structKTfwd_1_1mutation__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d7f/structKTfwd_1_1mutation.html">mutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest mutation type, adding just a selection coefficient and dominance to the interface.  <a href="../../d1/d7f/structKTfwd_1_1mutation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for gametes. A gamete is a container of pointers (iterators) to mutations + a count in the population.  <a href="../../d6/d90/structKTfwd_1_1gamete__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc3/structKTfwd_1_1n__is__zero.html">n_is_zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if member n == 0 Used internally.  <a href="../../d4/dc3/structKTfwd_1_1n__is__zero.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d1a/structKTfwd_1_1mutation__at__pos.html">mutation_at_pos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if std::fabs(m.pos-d) &lt;= std::numeric_limits&lt;double&gt;::epsilon() Returns true if std::fabs(m.pos-d) &lt;= std::numeric_limits&lt;double&gt;::epsilon()  <a href="../../d5/d1a/structKTfwd_1_1mutation__at__pos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/structKTfwd_1_1same__pos.html">same_pos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if std::fabs(m1.pos-m2.pos) &lt;= std::numeric_limits&lt;double&gt;::epsilon() Returns true if std::fabs(m1.pos-m2.pos) &lt;= std::numeric_limits&lt;double&gt;::epsilon()  <a href="../../da/d8f/structKTfwd_1_1same__pos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8e/structKTfwd_1_1equal__eps.html">equal_eps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if std::max(lhs,rhs)-std::min(lhs,rhs) &lt;= std::numeric_limits&lt;T&gt;::epsilon()  <a href="../../dc/d8e/structKTfwd_1_1equal__eps.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/structKTfwd_1_1mutation__remover.html">mutation_remover</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy determining how mutations are removed from gametes after sampling Policy determining how mutations are removed from gametes after sampling.  <a href="../../d4/de8/structKTfwd_1_1mutation__remover.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structKTfwd_1_1push__back__gamete.html">push_back_gamete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy for gametes.  <a href="../../d1/dcc/structKTfwd_1_1push__back__gamete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dff/structKTfwd_1_1insert__unique.html">insert_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy for gametes.  <a href="../../dd/dff/structKTfwd_1_1insert__unique.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5b/structKTfwd_1_1genetics101.html">genetics101</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ada593997c1d5b9a0ca50c09dcfc2f358"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt; <a class="el" href="../../d1/d7f/structKTfwd_1_1mutation.html">mutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ada593997c1d5b9a0ca50c09dcfc2f358">gamete</a></td></tr>
<tr class="memdesc:ada593997c1d5b9a0ca50c09dcfc2f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest gamete adds nothing to the interface of the base class.  <a href="#ada593997c1d5b9a0ca50c09dcfc2f358">More...</a><br/></td></tr>
<tr class="separator:ada593997c1d5b9a0ca50c09dcfc2f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a728e20cb60f82b818b5cc570722079a4"><td class="memTemplParams" colspan="2">template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a728e20cb60f82b818b5cc570722079a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a728e20cb60f82b818b5cc570722079a4">check_sum</a> (const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;gametes, const unsigned &amp;twoN)</td></tr>
<tr class="memdesc:a728e20cb60f82b818b5cc570722079a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise.  <a href="#a728e20cb60f82b818b5cc570722079a4">More...</a><br/></td></tr>
<tr class="separator:a728e20cb60f82b818b5cc570722079a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a49997b8e11c148177adea58dd916a6"><td class="memTemplParams" colspan="2">template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a3a49997b8e11c148177adea58dd916a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a3a49997b8e11c148177adea58dd916a6">check_sum</a> (const vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, const unsigned &amp;twoN)</td></tr>
<tr class="memdesc:a3a49997b8e11c148177adea58dd916a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise.  <a href="#a3a49997b8e11c148177adea58dd916a6">More...</a><br/></td></tr>
<tr class="separator:a3a49997b8e11c148177adea58dd916a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a46b107991548a40821e132496c1693"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename recombination_map , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a8a46b107991548a40821e132496c1693"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a8a46b107991548a40821e132496c1693">recombine_gametes</a> (gsl_rng *r, const double &amp;littler, list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *gametes, iterator_type &amp;g1, iterator_type &amp;g2, const recombination_map &amp;mf)</td></tr>
<tr class="memdesc:a8a46b107991548a40821e132496c1693"><td class="mdescLeft">&#160;</td><td class="mdescRight">recombination for individual-based forward simulations  <a href="#a8a46b107991548a40821e132496c1693">More...</a><br/></td></tr>
<tr class="separator:a8a46b107991548a40821e132496c1693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946efaa4a6095f4f2aadda44a809a477"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename diploid_fitness_function , typename mutation_removal_policy &gt; </td></tr>
<tr class="memitem:a946efaa4a6095f4f2aadda44a809a477"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a946efaa4a6095f4f2aadda44a809a477">sample_diploid</a> (gsl_rng *r, vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, const unsigned &amp;twoN, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f=0.)</td></tr>
<tr class="separator:a946efaa4a6095f4f2aadda44a809a477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a19140f729a493851685202d73c606"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename diploid_fitness_function , typename mutation_removal_policy &gt; </td></tr>
<tr class="memitem:a04a19140f729a493851685202d73c606"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a04a19140f729a493851685202d73c606">sample_diploid</a> (gsl_rng *r, vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, const unsigned &amp;twoN_curr, const unsigned &amp;twoN_next, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f)</td></tr>
<tr class="memdesc:a04a19140f729a493851685202d73c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wright-Fisher sampling of a single population of changing size Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness where population size changes from twoN_curr to twoN_next.  <a href="#a04a19140f729a493851685202d73c606">More...</a><br/></td></tr>
<tr class="separator:a04a19140f729a493851685202d73c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49f95a9fb81ad6e735437d956f59ddb"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </td></tr>
<tr class="memitem:ad49f95a9fb81ad6e735437d956f59ddb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad49f95a9fb81ad6e735437d956f59ddb">sample_diploid</a> (gsl_rng *r, vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *metapop, const unsigned *twoNs, const unsigned &amp;metapopsize, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp)</td></tr>
<tr class="separator:ad49f95a9fb81ad6e735437d956f59ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5647d600600d1e7c8254714c1b35d47f"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </td></tr>
<tr class="memitem:a5647d600600d1e7c8254714c1b35d47f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a5647d600600d1e7c8254714c1b35d47f">sample_diploid</a> (gsl_rng *r, vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *metapop, const unsigned *twoNs, const unsigned *twoNs_next, const unsigned &amp;metapopsize, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp)</td></tr>
<tr class="memdesc:a5647d600600d1e7c8254714c1b35d47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wright-Fisher sampling of a metapopulation population of constant size with inbreeding Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness under constant population size for a metapopulation.  <a href="#a5647d600600d1e7c8254714c1b35d47f">More...</a><br/></td></tr>
<tr class="separator:a5647d600600d1e7c8254714c1b35d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30567b5fe3c278ae72a9caaa744aaa2"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </td></tr>
<tr class="memitem:aa30567b5fe3c278ae72a9caaa744aaa2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#aa30567b5fe3c278ae72a9caaa744aaa2">sample_diploid</a> (gsl_rng *r, vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *metapop, const unsigned *twoNs, const unsigned &amp;metapopsize, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp, const double *fs)</td></tr>
<tr class="memdesc:aa30567b5fe3c278ae72a9caaa744aaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wright-Fisher sampling of a metapopulation population of changing size Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness under constant population size for a metapopulation.  <a href="#aa30567b5fe3c278ae72a9caaa744aaa2">More...</a><br/></td></tr>
<tr class="separator:aa30567b5fe3c278ae72a9caaa744aaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc37b4ba70df5adbced155f80d656029"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </td></tr>
<tr class="memitem:adc37b4ba70df5adbced155f80d656029"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#adc37b4ba70df5adbced155f80d656029">sample_diploid</a> (gsl_rng *r, vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *metapop, const unsigned *twoNs, const unsigned *twoNs_next, const unsigned &amp;metapopsize, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp, const double *fs)</td></tr>
<tr class="memdesc:adc37b4ba70df5adbced155f80d656029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wright-Fisher sampling of a metapopulation population of changing size with inbreeding Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness under constant population size for a metapopulation.  <a href="#adc37b4ba70df5adbced155f80d656029">More...</a><br/></td></tr>
<tr class="separator:adc37b4ba70df5adbced155f80d656029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bccb4fd1108616d626e371c3cf83c4"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename map_function &gt; </td></tr>
<tr class="memitem:a41bccb4fd1108616d626e371c3cf83c4"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a41bccb4fd1108616d626e371c3cf83c4">recombine</a> (gsl_rng *r, vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, const unsigned &amp;twoN, const double &amp;littler, const map_function &amp;mf, const double &amp;f=0)</td></tr>
<tr class="separator:a41bccb4fd1108616d626e371c3cf83c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761a0438d183384e5e8b49e89121d21e"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </td></tr>
<tr class="memitem:a761a0438d183384e5e8b49e89121d21e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a761a0438d183384e5e8b49e89121d21e">sample_diploid</a> (gsl_rng *r, gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N_curr, const double &amp;mu, const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f=0)</td></tr>
<tr class="separator:a761a0438d183384e5e8b49e89121d21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225d8aeed18091cd7ced5890f56afe52"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </td></tr>
<tr class="memitem:a225d8aeed18091cd7ced5890f56afe52"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a225d8aeed18091cd7ced5890f56afe52">sample_diploid</a> (gsl_rng *r, gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N_curr, const unsigned &amp;N_next, const double &amp;mu, const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f=0)</td></tr>
<tr class="separator:a225d8aeed18091cd7ced5890f56afe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1d8fa7c50cd8dadcceef879b13a2c5"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename metapop_gamete_vector_type_allocator , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_gamete_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </td></tr>
<tr class="memitem:aaf1d8fa7c50cd8dadcceef879b13a2c5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#aaf1d8fa7c50cd8dadcceef879b13a2c5">sample_diploid</a> (gsl_rng *r, metapop_gamete_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_gamete_vector_type_allocator &gt; *metapop, metapop_diploid_vector_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned *N_curr, const double &amp;mu, const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp, const migration_policy &amp;mig, const double *f=NULL)</td></tr>
<tr class="separator:aaf1d8fa7c50cd8dadcceef879b13a2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d97cd41a47a5e01dd034b94e16f49f2"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename metapop_gamete_vector_type_allocator , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_gamete_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </td></tr>
<tr class="memitem:a9d97cd41a47a5e01dd034b94e16f49f2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9d97cd41a47a5e01dd034b94e16f49f2">sample_diploid</a> (gsl_rng *r, metapop_gamete_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_gamete_vector_type_allocator &gt; *metapop, metapop_diploid_vector_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned *N_curr, const unsigned *N_next, const double &amp;mu, const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;mmodel, const recombination_policy &amp;rec_pol, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function_container &amp;ffs, const mutation_removal_policy &amp;mp, const migration_policy &amp;mig, const double *f=NULL)</td></tr>
<tr class="memdesc:a9d97cd41a47a5e01dd034b94e16f49f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evolve a metapopulation where demes may be changing size. For individual-based sims. Evolve a metapopulation where demes may be changing size. For individual-based sims.  <a href="#a9d97cd41a47a5e01dd034b94e16f49f2">More...</a><br/></td></tr>
<tr class="separator:a9d97cd41a47a5e01dd034b94e16f49f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade94ef65f07d1e664a19f20d2582728d"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </td></tr>
<tr class="memitem:ade94ef65f07d1e664a19f20d2582728d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ade94ef65f07d1e664a19f20d2582728d">sample_diploid</a> (gsl_rng *r, glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *gametes, diploid_vector_type&lt; locus_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N_curr, const unsigned &amp;N_next, const double *mu, const mutation_model_container &amp;mmodel, const recombination_policy_container &amp;rec_policies, const double *r_between_loci, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f)</td></tr>
<tr class="separator:ade94ef65f07d1e664a19f20d2582728d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6b4b4c12ce030e4bd1f32a0cd95b3c"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </td></tr>
<tr class="memitem:aaa6b4b4c12ce030e4bd1f32a0cd95b3c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#aaa6b4b4c12ce030e4bd1f32a0cd95b3c">sample_diploid</a> (gsl_rng *r, glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *gametes, diploid_vector_type&lt; locus_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *diploids, mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *mutations, const unsigned &amp;N, const double *mu, const mutation_model_container &amp;mmodel, const recombination_policy_container &amp;rec_policies, const double *r_between_loci, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy_mut, const diploid_fitness_function &amp;ff, const mutation_removal_policy &amp;mp, const double &amp;f)</td></tr>
<tr class="separator:aaa6b4b4c12ce030e4bd1f32a0cd95b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105a292a1e5c591d64d14caf4062e2f3"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename fitness_updating_policy_hom , typename fitness_updating_policy_het &gt; </td></tr>
<tr class="memitem:a105a292a1e5c591d64d14caf4062e2f3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a105a292a1e5c591d64d14caf4062e2f3">site_dependent_fitness2</a> (iterator_type __first1, iterator_type __last1, iterator_type __first2, iterator_type __last2, const fitness_updating_policy_hom &amp;fpol_hom, const fitness_updating_policy_het &amp;fpol_het, const double &amp;starting_fitness=1.)</td></tr>
<tr class="separator:a105a292a1e5c591d64d14caf4062e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05d39195307329f16205963a265b41f"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_allocator_type , typename mutation_type , typename list_allocator_type , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:af05d39195307329f16205963a265b41f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#af05d39195307329f16205963a265b41f">init_with_ms</a> (Sequence::SimData &amp;d, vector_type&lt; gamete_type, vector_allocator_type &gt; *gametes, list_type&lt; mutation_type, list_allocator_type &gt; *mutations, const unsigned &amp;max_chroms=std::numeric_limits&lt; unsigned &gt;::max())</td></tr>
<tr class="memdesc:af05d39195307329f16205963a265b41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a population with results from a coalescent simulation Takes an object of type Sequence::SimData from libsequence and initialized a population.  <a href="#af05d39195307329f16205963a265b41f">More...</a><br/></td></tr>
<tr class="separator:af05d39195307329f16205963a265b41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec3c87ea53ac5d614b34080d177ece2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:a5ec3c87ea53ac5d614b34080d177ece2"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a5ec3c87ea53ac5d614b34080d177ece2">insert_at_end</a> (const T &amp;t, cT *ct)</td></tr>
<tr class="memdesc:a5ec3c87ea53ac5d614b34080d177ece2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#a5ec3c87ea53ac5d614b34080d177ece2">More...</a><br/></td></tr>
<tr class="separator:a5ec3c87ea53ac5d614b34080d177ece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48c3a9aea8e34355c01c986ba534d26"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:ae48c3a9aea8e34355c01c986ba534d26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ae48c3a9aea8e34355c01c986ba534d26">push_at_end</a> (const T &amp;t, cT *ct)</td></tr>
<tr class="memdesc:ae48c3a9aea8e34355c01c986ba534d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy Works via push_back instead of insert, so there is no return value.  <a href="#ae48c3a9aea8e34355c01c986ba534d26">More...</a><br/></td></tr>
<tr class="separator:ae48c3a9aea8e34355c01c986ba534d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab010eee5104ec79dee18f987dfb4fdd7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:ab010eee5104ec79dee18f987dfb4fdd7"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ab010eee5104ec79dee18f987dfb4fdd7">update_if_exists_insert</a> (const T &amp;t, cT *ct)</td></tr>
<tr class="memdesc:ab010eee5104ec79dee18f987dfb4fdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#ab010eee5104ec79dee18f987dfb4fdd7">More...</a><br/></td></tr>
<tr class="separator:ab010eee5104ec79dee18f987dfb4fdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6277a0a5fb32b00839d973b5d5de4db2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:a6277a0a5fb32b00839d973b5d5de4db2"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a6277a0a5fb32b00839d973b5d5de4db2">insert_if_not_found</a> (const T &amp;t, cT *ct)</td></tr>
<tr class="separator:a6277a0a5fb32b00839d973b5d5de4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b12060a74d27f79272e437fce296af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:ac4b12060a74d27f79272e437fce296af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ac4b12060a74d27f79272e437fce296af">update_if_exists_push</a> (const T &amp;t, cT *ct)</td></tr>
<tr class="memdesc:ac4b12060a74d27f79272e437fce296af"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#ac4b12060a74d27f79272e437fce296af">More...</a><br/></td></tr>
<tr class="separator:ac4b12060a74d27f79272e437fce296af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01bf96e48511f9cd41c2e144b5bd55e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename cT &gt; </td></tr>
<tr class="memitem:ae01bf96e48511f9cd41c2e144b5bd55e"><td class="memTemplItemLeft" align="right" valign="top">cT::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ae01bf96e48511f9cd41c2e144b5bd55e">insert_new_or_fail</a> (const T &amp;t, cT *ct)</td></tr>
<tr class="memdesc:ae01bf96e48511f9cd41c2e144b5bd55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insertion policy.  <a href="#ae01bf96e48511f9cd41c2e144b5bd55e">More...</a><br/></td></tr>
<tr class="separator:ae01bf96e48511f9cd41c2e144b5bd55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a62425d621d173561c44a026b2f60a"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type &gt; </td></tr>
<tr class="memitem:a58a62425d621d173561c44a026b2f60a"><td class="memTemplItemLeft" align="right" valign="top">list_type::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a58a62425d621d173561c44a026b2f60a">insert_mutation_at_end</a> (const mutation_type &amp;m, list_type *mutations)</td></tr>
<tr class="memdesc:a58a62425d621d173561c44a026b2f60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion policy for a mutation.  <a href="#a58a62425d621d173561c44a026b2f60a">More...</a><br/></td></tr>
<tr class="separator:a58a62425d621d173561c44a026b2f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f8316904e833976fc0464dce618c6e"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type &gt; </td></tr>
<tr class="memitem:ae5f8316904e833976fc0464dce618c6e"><td class="memTemplItemLeft" align="right" valign="top">list_type::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ae5f8316904e833976fc0464dce618c6e">insert_unique_or_fail</a> (const mutation_type &amp;m, list_type *mutations)</td></tr>
<tr class="separator:ae5f8316904e833976fc0464dce618c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec919521b4cb51ca9d7d8a7afabfdea"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_writer , typename ostreamtype &gt; </td></tr>
<tr class="memitem:a3ec919521b4cb51ca9d7d8a7afabfdea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a3ec919521b4cb51ca9d7d8a7afabfdea">write_binary_pop</a> (const vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, list_type&lt; mutation_type, list_type_allocator &gt; *mutations, const mutation_writer &amp;mw, ostreamtype &amp;buffer)</td></tr>
<tr class="separator:a3ec919521b4cb51ca9d7d8a7afabfdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc8a3fbd86d33660aa1ebca19be651f"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type2, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_writer_type , typename ostreamtype &gt; </td></tr>
<tr class="memitem:abcc8a3fbd86d33660aa1ebca19be651f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#abcc8a3fbd86d33660aa1ebca19be651f">write_binary_metapop</a> (const vector_type2&lt; vector_type&lt; gamete_type, vector_type_allocator &gt;, vector_type_allocator2 &gt; *gametes, list_type&lt; mutation_type, list_type_allocator &gt; *mutations, const mutation_writer_type &amp;mw, ostreamtype &amp;buffer)</td></tr>
<tr class="separator:abcc8a3fbd86d33660aa1ebca19be651f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86f256af3adb31cc09ad797b3d76c6e"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_reader , typename istreamtype &gt; </td></tr>
<tr class="memitem:aa86f256af3adb31cc09ad797b3d76c6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#aa86f256af3adb31cc09ad797b3d76c6e">read_binary_pop</a> (vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, list_type&lt; mutation_type, list_type_allocator &gt; *mutations, const mutation_reader &amp;mr, istreamtype &amp;in)</td></tr>
<tr class="separator:aa86f256af3adb31cc09ad797b3d76c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51661a15c5305410ac8e9ae862ad3f0b"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_reader_type &gt; </td></tr>
<tr class="memitem:a51661a15c5305410ac8e9ae862ad3f0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a51661a15c5305410ac8e9ae862ad3f0b">read_binary_pop</a> (gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt; *diploids, const mutation_reader_type &amp;mr, gzFile gzin)</td></tr>
<tr class="separator:a51661a15c5305410ac8e9ae862ad3f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5275d35cfd958887603103fa8ad9ed80"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type2, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_reader , typename istreamtype &gt; </td></tr>
<tr class="memitem:a5275d35cfd958887603103fa8ad9ed80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a5275d35cfd958887603103fa8ad9ed80">read_binary_metapop</a> (vector_type2&lt; vector_type&lt; gamete_type, vector_type_allocator &gt;, vector_type_allocator2 &gt; *gametes, list_type&lt; mutation_type, list_type_allocator &gt; *mutations, const mutation_reader &amp;mr, istreamtype &amp;in)</td></tr>
<tr class="memdesc:a5275d35cfd958887603103fa8ad9ed80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the metapopulation back from a binary-format file Read the metapopulation back from a binary-format file.  <a href="#a5275d35cfd958887603103fa8ad9ed80">More...</a><br/></td></tr>
<tr class="separator:a5275d35cfd958887603103fa8ad9ed80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c16f28e2e1e883e7cff3f0aa8a004e"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type2, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_reader &gt; </td></tr>
<tr class="memitem:a54c16f28e2e1e883e7cff3f0aa8a004e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a54c16f28e2e1e883e7cff3f0aa8a004e">read_binary_metapop</a> (vector_type2&lt; vector_type&lt; gamete_type, vector_type_allocator &gt;, vector_type_allocator2 &gt; *gametes, list_type&lt; mutation_type, list_type_allocator &gt; *mutations, const mutation_reader &amp;mr, gzFile gzin)</td></tr>
<tr class="memdesc:a54c16f28e2e1e883e7cff3f0aa8a004e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the metapopulation back from a compressed binary-format file Read the metapopulation back from a compressed binary-format file.  <a href="#a54c16f28e2e1e883e7cff3f0aa8a004e">More...</a><br/></td></tr>
<tr class="separator:a54c16f28e2e1e883e7cff3f0aa8a004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e38d4088239ecf2c9af7b11a13c3497"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_writer_type , typename ostreamtype &gt; </td></tr>
<tr class="memitem:a9e38d4088239ecf2c9af7b11a13c3497"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9e38d4088239ecf2c9af7b11a13c3497">write_binary_pop</a> (const gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, const diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt; *diploids, const mutation_writer_type &amp;mw, ostreamtype &amp;buffer)</td></tr>
<tr class="memdesc:a9e38d4088239ecf2c9af7b11a13c3497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write population to binary-format file for individual-based simulations.  <a href="#a9e38d4088239ecf2c9af7b11a13c3497">More...</a><br/></td></tr>
<tr class="separator:a9e38d4088239ecf2c9af7b11a13c3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7584c8678ddbc46067710415cdd9e6"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_reader_type , typename istreamtype &gt; </td></tr>
<tr class="memitem:a0b7584c8678ddbc46067710415cdd9e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a0b7584c8678ddbc46067710415cdd9e6">read_binary_pop</a> (gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *gametes, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt; *diploids, const mutation_reader_type &amp;mr, istreamtype &amp;in)</td></tr>
<tr class="memdesc:a0b7584c8678ddbc46067710415cdd9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the population back from a binary-format file for individual-based simulations.  <a href="#a0b7584c8678ddbc46067710415cdd9e6">More...</a><br/></td></tr>
<tr class="separator:a0b7584c8678ddbc46067710415cdd9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edd4d917ccd2f2dc5dcf3529c8952c3"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename metapop_vector_type_allocator , template&lt; typename, typename &gt; class metapop_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_writer_type , typename ostreamtype &gt; </td></tr>
<tr class="memitem:a8edd4d917ccd2f2dc5dcf3529c8952c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a8edd4d917ccd2f2dc5dcf3529c8952c3">write_binary_metapop</a> (const metapop_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_vector_type_allocator &gt; *metapop, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, const diploid_vv_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *diploids, const mutation_writer_type &amp;mw, ostreamtype &amp;buffer)</td></tr>
<tr class="separator:a8edd4d917ccd2f2dc5dcf3529c8952c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eab931b65ce0864ed1ecf5a4d111b95"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename metapop_vector_type_allocator , template&lt; typename, typename &gt; class metapop_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type , typename istreamtype &gt; </td></tr>
<tr class="memitem:a0eab931b65ce0864ed1ecf5a4d111b95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a0eab931b65ce0864ed1ecf5a4d111b95">read_binary_metapop</a> (metapop_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_vector_type_allocator &gt; *metapop, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, diploid_vv_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *diploids, const mutation_reader_type &amp;mr, istreamtype &amp;in)</td></tr>
<tr class="memdesc:a0eab931b65ce0864ed1ecf5a4d111b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the metapopulation back from a binary-format file for individual-based simulations Read the metapopulation back from a binary-format file.  <a href="#a0eab931b65ce0864ed1ecf5a4d111b95">More...</a><br/></td></tr>
<tr class="separator:a0eab931b65ce0864ed1ecf5a4d111b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005e06cb708cb010eaed381cadaee2c7"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename metapop_vector_type_allocator , template&lt; typename, typename &gt; class metapop_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type &gt; </td></tr>
<tr class="memitem:a005e06cb708cb010eaed381cadaee2c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a005e06cb708cb010eaed381cadaee2c7">read_binary_metapop</a> (metapop_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_vector_type_allocator &gt; *metapop, mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *mutations, diploid_vv_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *diploids, const mutation_reader_type &amp;mr, gzFile gzin)</td></tr>
<tr class="memdesc:a005e06cb708cb010eaed381cadaee2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the metapopulation back from a compressed binary-format file for individual-based simulations Read the metapopulation back from a compressed binary-format file.  <a href="#a005e06cb708cb010eaed381cadaee2c7">More...</a><br/></td></tr>
<tr class="separator:a005e06cb708cb010eaed381cadaee2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5980168c14a3c1d55790e506a49336"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:afc5980168c14a3c1d55790e506a49336"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#afc5980168c14a3c1d55790e506a49336">migrate_from_to</a> (gsl_rng *r, vector_type&lt; gamete_type, vector_type_allocator &gt; *source, vector_type&lt; gamete_type, vector_type_allocator &gt; *dest, const unsigned &amp;nmigrants)</td></tr>
<tr class="separator:afc5980168c14a3c1d55790e506a49336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d1af58a12e56b980a03b2056770370"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:ad1d1af58a12e56b980a03b2056770370"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad1d1af58a12e56b980a03b2056770370">migrate</a> (gsl_rng *r, vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes1, vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes2, const unsigned &amp;twoN_1, const unsigned &amp;twoN_2, const double &amp;m)</td></tr>
<tr class="separator:ad1d1af58a12e56b980a03b2056770370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9566be0bd568e2e75b02b1f46457c25c"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename mutation_model , typename gamete_insertion_policy , typename mutation_insertion_policy , typename vector_type_allocator , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a9566be0bd568e2e75b02b1f46457c25c"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9566be0bd568e2e75b02b1f46457c25c">mutate</a> (gsl_rng *r, vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, list_type&lt; typename gamete_type::mutation_type, list_type_allocator &gt; *mutations, const double &amp;mu, const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;mmodel, const gamete_insertion_policy &amp;gpolicy, const mutation_insertion_policy &amp;mpolicy)</td></tr>
<tr class="separator:a9566be0bd568e2e75b02b1f46457c25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949b79d4df5bc10c6c1b31d311e4a392"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename mutation_model , typename mutation_insertion_policy , typename gamete_insertion_policy , typename list_type_allocator , typename list_type_allocator2 , template&lt; typename, typename &gt; class list_type, template&lt; typename, typename &gt; class list_type2&gt; </td></tr>
<tr class="memitem:a949b79d4df5bc10c6c1b31d311e4a392"><td class="memTemplItemLeft" align="right" valign="top">iterator_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a949b79d4df5bc10c6c1b31d311e4a392">mutate_gamete</a> (gsl_rng *r, const double &amp;mu, list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *gametes, list_type2&lt; typename iterator_type::value_type::mutation_type, list_type_allocator2 &gt; *mutations, iterator_type &amp;g, const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;mmodel, const mutation_insertion_policy &amp;mpolicy, const gamete_insertion_policy &amp;gpolicy)</td></tr>
<tr class="memdesc:a949b79d4df5bc10c6c1b31d311e4a392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply mutation model to an individual gamete. Used for individual-based forward simulations.  <a href="#a949b79d4df5bc10c6c1b31d311e4a392">More...</a><br/></td></tr>
<tr class="separator:a949b79d4df5bc10c6c1b31d311e4a392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4ac5932b4c1d311486946b2b6f612c"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type &gt; </td></tr>
<tr class="memitem:a2b4ac5932b4c1d311486946b2b6f612c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a2b4ac5932b4c1d311486946b2b6f612c">population_sfs</a> (iterator_type beg, iterator_type end, const unsigned &amp;N)</td></tr>
<tr class="separator:a2b4ac5932b4c1d311486946b2b6f612c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a8a0218ff1f5dfc33268fd5243207b"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:ad9a8a0218ff1f5dfc33268fd5243207b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad9a8a0218ff1f5dfc33268fd5243207b">sample_sfs</a> (gsl_rng *r, const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;gametes, const unsigned &amp;n, const unsigned &amp;N)</td></tr>
<tr class="separator:ad9a8a0218ff1f5dfc33268fd5243207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61734beb98c158306314c7f7b94c5711"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a61734beb98c158306314c7f7b94c5711"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a61734beb98c158306314c7f7b94c5711">ms_sample</a> (gsl_rng *r, const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;gametes, const unsigned &amp;n, const unsigned &amp;N, bool remove_fixed=true)</td></tr>
<tr class="separator:a61734beb98c158306314c7f7b94c5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe92f5f5c94285825e09978c03fe5a97"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:afe92f5f5c94285825e09978c03fe5a97"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt;, std::vector<br class="typebreak"/>
&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#afe92f5f5c94285825e09978c03fe5a97">ms_sample_separate</a> (gsl_rng *r, const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;gametes, const unsigned &amp;n, const unsigned &amp;N, bool remove_fixed=true)</td></tr>
<tr class="separator:afe92f5f5c94285825e09978c03fe5a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52e67c0735f3277e4800968a4f9fdc2"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:aa52e67c0735f3277e4800968a4f9fdc2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#aa52e67c0735f3277e4800968a4f9fdc2">ms_sample</a> (gsl_rng *r, const vector_type&lt; std::pair&lt; iterator_type, iterator_type &gt;, allocator &gt; *diploids, const unsigned &amp;n, const bool &amp;remove_fixed=true)</td></tr>
<tr class="memdesc:aa52e67c0735f3277e4800968a4f9fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling from a population in an individual-based simulation.  <a href="#aa52e67c0735f3277e4800968a4f9fdc2">More...</a><br/></td></tr>
<tr class="separator:aa52e67c0735f3277e4800968a4f9fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb4b96b8394d5df064690abc803bd64"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type , typename allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a9fb4b96b8394d5df064690abc803bd64"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt;, std::vector<br class="typebreak"/>
&lt; std::pair&lt; double, <br class="typebreak"/>
std::string &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9fb4b96b8394d5df064690abc803bd64">ms_sample_separate</a> (gsl_rng *r, const vector_type&lt; std::pair&lt; iterator_type, iterator_type &gt;, allocator &gt; *diploids, const unsigned &amp;n, const bool &amp;remove_fixed=true)</td></tr>
<tr class="memdesc:a9fb4b96b8394d5df064690abc803bd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling from a population in an individual-based simulation. Selected and neutral mutations returned separately.  <a href="#a9fb4b96b8394d5df064690abc803bd64">More...</a><br/></td></tr>
<tr class="separator:a9fb4b96b8394d5df064690abc803bd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beb352c8831c316862a18f3ebef4bbf"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename gamete_allocator_type , typename gamete_allocator_type2 , typename mutation_type , typename mutation_allocator_type , typename mutation_allocator_type2 , template&lt; typename, typename &gt; class source_gamete_container, template&lt; typename, typename &gt; class source_mut_container, template&lt; typename, typename &gt; class dest_gamete_container, template&lt; typename, typename &gt; class dest_mut_container&gt; </td></tr>
<tr class="memitem:a9beb352c8831c316862a18f3ebef4bbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9beb352c8831c316862a18f3ebef4bbf">valid_copy</a> (const source_gamete_container&lt; gamete_type, gamete_allocator_type &gt; &amp;gametes, const source_mut_container&lt; mutation_type, mutation_allocator_type &gt; &amp;mutations, dest_gamete_container&lt; gamete_type, gamete_allocator_type2 &gt; &amp;gametes_destination, dest_mut_container&lt; mutation_type, mutation_allocator_type2 &gt; &amp;mutations_destination)</td></tr>
<tr class="separator:a9beb352c8831c316862a18f3ebef4bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ac7525d84cfec32e3007029da92cee"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a91ac7525d84cfec32e3007029da92cee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a91ac7525d84cfec32e3007029da92cee">uncheck</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations)</td></tr>
<tr class="separator:a91ac7525d84cfec32e3007029da92cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a4fcecb15c101816ccdd15eefd6a1b"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a86a4fcecb15c101816ccdd15eefd6a1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a86a4fcecb15c101816ccdd15eefd6a1b">remove_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations)</td></tr>
<tr class="separator:a86a4fcecb15c101816ccdd15eefd6a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73eeda26047df89b8ea303c0d8a6b74"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </td></tr>
<tr class="memitem:ad73eeda26047df89b8ea303c0d8a6b74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#ad73eeda26047df89b8ea303c0d8a6b74">remove_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations, mutation_lookup_table *lookup)</td></tr>
<tr class="separator:ad73eeda26047df89b8ea303c0d8a6b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e666ea27d38bdfc539ffd23653eaa9"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </td></tr>
<tr class="memitem:a84e666ea27d38bdfc539ffd23653eaa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a84e666ea27d38bdfc539ffd23653eaa9">remove_fixed_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations, vector_type&lt; mutation_type, vector_type_allocator1 &gt; *fixations, vector_type&lt; unsigned, vector_type_allocator2 &gt; *fixation_times, const unsigned &amp;generation, const unsigned &amp;twoN)</td></tr>
<tr class="separator:a84e666ea27d38bdfc539ffd23653eaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc0bd4b96e6164ec339823c85de235e"><td class="memTemplParams" colspan="2">template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </td></tr>
<tr class="memitem:adbc0bd4b96e6164ec339823c85de235e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#adbc0bd4b96e6164ec339823c85de235e">remove_fixed_lost</a> (list_type&lt; mutation_type, list_type_allocator &gt; *mutations, vector_type&lt; mutation_type, vector_type_allocator1 &gt; *fixations, vector_type&lt; unsigned, vector_type_allocator2 &gt; *fixation_times, mutation_lookup_table *lookup, const unsigned &amp;generation, const unsigned &amp;twoN)</td></tr>
<tr class="separator:adbc0bd4b96e6164ec339823c85de235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8636e0942d61b4d30bd60709b4bd2c10"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type &gt; </td></tr>
<tr class="memitem:a8636e0942d61b4d30bd60709b4bd2c10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a8636e0942d61b4d30bd60709b4bd2c10">adjust_mutation_counts</a> (iterator_type g, const unsigned &amp;n)</td></tr>
<tr class="memdesc:a8636e0942d61b4d30bd60709b4bd2c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">used internally  <a href="#a8636e0942d61b4d30bd60709b4bd2c10">More...</a><br/></td></tr>
<tr class="separator:a8636e0942d61b4d30bd60709b4bd2c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3dab17dd143c95bd6de883e729aaa6"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a9b3dab17dd143c95bd6de883e729aaa6"><td class="memTemplItemLeft" align="right" valign="top">vector_type&lt; gamete_type, <br class="typebreak"/>
vector_type_allocator &gt;<br class="typebreak"/>
::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9b3dab17dd143c95bd6de883e729aaa6">pgam</a> (gsl_rng *r, vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes)</td></tr>
<tr class="memdesc:a9b3dab17dd143c95bd6de883e729aaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a gamete proportional to its frequency Pick a gamete proportional to its frequency.  <a href="#a9b3dab17dd143c95bd6de883e729aaa6">More...</a><br/></td></tr>
<tr class="separator:a9b3dab17dd143c95bd6de883e729aaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9cddaf4fdce8362637f127179cece8"><td class="memTemplParams" colspan="2">template&lt;typename gamete_type , typename vector_type_allocator , typename mutation_removal_policy , template&lt; typename, typename &gt; class vector_type&gt; </td></tr>
<tr class="memitem:a9b9cddaf4fdce8362637f127179cece8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a9b9cddaf4fdce8362637f127179cece8">update_gamete_list</a> (vector_type&lt; gamete_type, vector_type_allocator &gt; *gametes, const unsigned &amp;twoN, const mutation_removal_policy &amp;mrp)</td></tr>
<tr class="separator:a9b9cddaf4fdce8362637f127179cece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2696271f4be7ee04aa58c9253e18a3"><td class="memTemplParams" colspan="2">template&lt;typename iterator_type &gt; </td></tr>
<tr class="memitem:a6a2696271f4be7ee04aa58c9253e18a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8b/namespaceKTfwd.html#a6a2696271f4be7ee04aa58c9253e18a3">multinomial_sample_gametes</a> (gsl_rng *r, iterator_type gbegin, const size_t &amp;ngametes, const double *efreqs, const unsigned &amp;twoN)</td></tr>
<tr class="memdesc:a6a2696271f4be7ee04aa58c9253e18a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multinomial sampling of gametes Called by <a class="el" href="../../da/d8b/namespaceKTfwd.html#a946efaa4a6095f4f2aadda44a809a477">KTfwd::sample_diploid</a>.  <a href="#a6a2696271f4be7ee04aa58c9253e18a3">More...</a><br/></td></tr>
<tr class="separator:a6a2696271f4be7ee04aa58c9253e18a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The primary namespace defined by this library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ada593997c1d5b9a0ca50c09dcfc2f358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d6/d90/structKTfwd_1_1gamete__base.html">gamete_base</a>&lt;<a class="el" href="../../d1/d7f/structKTfwd_1_1mutation.html">mutation</a>&gt; <a class="el" href="../../da/d8b/namespaceKTfwd.html#ada593997c1d5b9a0ca50c09dcfc2f358">KTfwd::gamete</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The simplest gamete adds nothing to the interface of the base class. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8636e0942d61b4d30bd60709b4bd2c10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::adjust_mutation_counts </td>
          <td>(</td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used internally </p>
<dl class="section note"><dt>Note</dt><dd>Will need a specialization if types have other data that need updating </dd></dl>

</div>
</div>
<a class="anchor" id="a728e20cb60f82b818b5cc570722079a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool KTfwd::check_sum </td>
          <td>(</td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d81/diploid_8cc-example.html#a15">diploid.cc</a>, <a class="el" href="../../d7/dd8/diploid_binaryIO_8cc-example.html#a24">diploid_binaryIO.cc</a>, <a class="el" href="../../d7/d24/diploid_fixed_sh_8cc-example.html#a10">diploid_fixed_sh.cc</a>, <a class="el" href="../../df/df6/diploid_fixed_sh_ind_8cc-example.html#a6">diploid_fixed_sh_ind.cc</a>, <a class="el" href="../../d3/da0/diploid_gzbinaryIO_8cc-example.html#a24">diploid_gzbinaryIO.cc</a>, <a class="el" href="../../db/de9/diploid_ind_8cc-example.html#a16">diploid_ind.cc</a>, <a class="el" href="../../dd/da1/diploid_twopop_mig_8cc-example.html#a18">diploid_twopop_mig.cc</a>, <a class="el" href="../../d3/d0a/RHH_8cc-example.html#a13">RHH.cc</a>, and <a class="el" href="../../dc/d1a/TFL2013_8cc-example.html#a16">TFL2013.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3a49997b8e11c148177adea58dd916a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vector_type_allocator , typename gamete_type , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool KTfwd::check_sum </td>
          <td>(</td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sum of counts in gametes equals twoN, false otherwise Returns true if the sum of counts in gametes equals twoN, false otherwise. </p>

</div>
</div>
<a class="anchor" id="af05d39195307329f16205963a265b41f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_allocator_type , typename mutation_type , typename list_allocator_type , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::init_with_ms </td>
          <td>(</td>
          <td class="paramtype">Sequence::SimData &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_allocator_type &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; mutation_type, list_allocator_type &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>max_chroms</em> = <code>std::numeric_limits&lt;unsigned&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a population with results from a coalescent simulation Takes an object of type Sequence::SimData from libsequence and initialized a population. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>A Sequence::SimData object </td></tr>
    <tr><td class="paramname">gametes</td><td>Destination for gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for mutations </td></tr>
    <tr><td class="paramname">max_chroms</td><td>The max number of gametes to read from d. Default is std::numeric_limits&lt;unsigned&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: It can be problematic using the ouptut from simulators that write to ASCI (plain text) files. If mutation positions are on the interval [0,1), then rounding during write will often truncate such that the data look like there are two mutations at the same site. This function attempts to control that in the following way: If three mutations in the file are at positions A, A, and B, then the positions are converted to ,A, A + (B-A)/2, and B. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ec3c87ea53ac5d614b34080d177ece2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::insert_at_end </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>A common use of this policy will be when a mutation model always gives rise to a gamete that does not currently exist in the population, such as the infinitely-many sites model of mutations. For such models, it is sufficient to simply append the new gamete to the existing vector.</p>
<p>Note: it is silly to pass ng to this function with ng.n = 0.</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6277a0a5fb32b00839d973b5d5de4db2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::insert_if_not_found </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a58a62425d621d173561c44a026b2f60a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_type::iterator KTfwd::insert_mutation_at_end </td>
          <td>(</td>
          <td class="paramtype">const mutation_type &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type *&#160;</td>
          <td class="paramname"><em>mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion policy for a mutation. </p>
<p>Simply appends it to end of list_type mutations</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae01bf96e48511f9cd41c2e144b5bd55e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::insert_new_or_fail </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>If t is not found in ct, then insert t at end of ct, else return ct-&gt;end() </p>

</div>
</div>
<a class="anchor" id="ae5f8316904e833976fc0464dce618c6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list_type::iterator KTfwd::insert_unique_or_fail </td>
          <td>(</td>
          <td class="paramtype">const mutation_type &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type *&#160;</td>
          <td class="paramname"><em>mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad1d1af58a12e56b980a03b2056770370"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::migrate </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symmetric migration between two populations at rate m per generation.</p>
<p>Here, m is defined such that Poissomn(twoN*m) gametes migrate from pop1 to pop2 and then from pop2 to pop1.</p>
<p>A migration event is implemented via <a class="el" href="../../da/d8b/namespaceKTfwd.html#afc5980168c14a3c1d55790e506a49336">KTfwd::migrate_from_to</a>, which defines a migration event as the replacement of a gamete in the destiniation population with a gamete from the source. The frequency of the source population gamete remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a GSL random number generator </td></tr>
    <tr><td class="paramname">gametes1</td><td>Pointer to gametes from source population </td></tr>
    <tr><td class="paramname">gametes2</td><td>Pointer to gametes from destination population </td></tr>
    <tr><td class="paramname">twoN_1</td><td>2N for gametes1 </td></tr>
    <tr><td class="paramname">twoN_2</td><td>2N for gametes2 </td></tr>
    <tr><td class="paramname">m</td><td>probability that a chromosome in population B is replaced by one from population A </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/da1/diploid_twopop_mig_8cc-example.html#a21">diploid_twopop_mig.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afc5980168c14a3c1d55790e506a49336"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::migrate_from_to </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nmigrants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a61734beb98c158306314c7f7b94c5711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;double, std::string&gt; &gt; KTfwd::ms_sample </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_fixed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d81/diploid_8cc-example.html#a18">diploid.cc</a>, <a class="el" href="../../db/de9/diploid_ind_8cc-example.html#a17">diploid_ind.cc</a>, and <a class="el" href="../../dd/da1/diploid_twopop_mig_8cc-example.html#a22">diploid_twopop_mig.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa52e67c0735f3277e4800968a4f9fdc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;double,std::string&gt; &gt; KTfwd::ms_sample </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_type&lt; std::pair&lt; iterator_type, iterator_type &gt;, allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>remove_fixed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sampling from a population in an individual-based simulation. </p>

</div>
</div>
<a class="anchor" id="afe92f5f5c94285825e09978c03fe5a97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::pair&lt;double, std::string&gt; &gt; , std::vector&lt; std::pair&lt;double, std::string&gt; &gt; &gt; KTfwd::ms_sample_separate </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_fixed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d7/d24/diploid_fixed_sh_8cc-example.html#a13">diploid_fixed_sh.cc</a>, <a class="el" href="../../df/df6/diploid_fixed_sh_ind_8cc-example.html#a12">diploid_fixed_sh_ind.cc</a>, <a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a25">migsel_ind.cc</a>, and <a class="el" href="../../d3/d0a/RHH_8cc-example.html#a16">RHH.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9fb4b96b8394d5df064690abc803bd64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt; std::pair&lt;double,std::string&gt; &gt;, std::vector&lt; std::pair&lt;double,std::string&gt; &gt; &gt; KTfwd::ms_sample_separate </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_type&lt; std::pair&lt; iterator_type, iterator_type &gt;, allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>remove_fixed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sampling from a population in an individual-based simulation. Selected and neutral mutations returned separately. </p>

</div>
</div>
<a class="anchor" id="a6a2696271f4be7ee04aa58c9253e18a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::multinomial_sample_gametes </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>gbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ngametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>efreqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multinomial sampling of gametes Called by <a class="el" href="../../da/d8b/namespaceKTfwd.html#a946efaa4a6095f4f2aadda44a809a477">KTfwd::sample_diploid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">gbegin</td><td>Iterator to the start of a vector of gametes </td></tr>
    <tr><td class="paramname">ngametes</td><td>The size of the vector whose beginning is gbegin </td></tr>
    <tr><td class="paramname">efreqs</td><td>Vector of frequencies from which to sample. Must sum to 1 (not checked!). Typically, this would be the expected frequency of gbegin to (gbegin+i) in the next generation </td></tr>
    <tr><td class="paramname">twoN</td><td>Twice the number of diploids </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9566be0bd568e2e75b02b1f46457c25c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename mutation_model , typename gamete_insertion_policy , typename mutation_insertion_policy , typename vector_type_allocator , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned KTfwd::mutate </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; typename gamete_type::mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d81/diploid_8cc-example.html#a16">diploid.cc</a>, <a class="el" href="../../d7/dd8/diploid_binaryIO_8cc-example.html#a25">diploid_binaryIO.cc</a>, <a class="el" href="../../d7/d24/diploid_fixed_sh_8cc-example.html#a11">diploid_fixed_sh.cc</a>, <a class="el" href="../../d3/da0/diploid_gzbinaryIO_8cc-example.html#a25">diploid_gzbinaryIO.cc</a>, <a class="el" href="../../dd/da1/diploid_twopop_mig_8cc-example.html#a19">diploid_twopop_mig.cc</a>, <a class="el" href="../../d3/d0a/RHH_8cc-example.html#a14">RHH.cc</a>, and <a class="el" href="../../dc/d1a/TFL2013_8cc-example.html#a17">TFL2013.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a949b79d4df5bc10c6c1b31d311e4a392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename mutation_model , typename mutation_insertion_policy , typename gamete_insertion_policy , typename list_type_allocator , typename list_type_allocator2 , template&lt; typename, typename &gt; class list_type, template&lt; typename, typename &gt; class list_type2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator_type KTfwd::mutate_gamete </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type2&lt; typename iterator_type::value_type::mutation_type, list_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply mutation model to an individual gamete. Used for individual-based forward simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">gametes</td><td>Pointer to the list of gametes in the population </td></tr>
    <tr><td class="paramname">mutations</td><td>Pointer to the list of mutations in the population </td></tr>
    <tr><td class="paramname">g</td><td>An iterator to the gamete that will be mutated by this function </td></tr>
    <tr><td class="paramname">mu</td><td>the TOTAL mutation rate per gamete </td></tr>
    <tr><td class="paramname">mmodel</td><td>Mutation model policy </td></tr>
    <tr><td class="paramname">gpolicy</td><td>Policy determining how new gametes are added to population </td></tr>
    <tr><td class="paramname">mpolicy</td><td>Policy determining how new mutations are added to the population</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>g is passed non-const and will be modified by mutation events. </dd>
<dd>
The type of g is vector_type&lt;gamete_type,vector_type_allocator &gt;::iterator </dd>
<dd>
Used in invididual-based forward simulations. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the newly-created gamete, or to g if no mutation occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3dab17dd143c95bd6de883e729aaa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector_type&lt;gamete_type,vector_type_allocator&gt;::iterator KTfwd::pgam </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pick a gamete proportional to its frequency Pick a gamete proportional to its frequency. </p>

</div>
</div>
<a class="anchor" id="a2b4ac5932b4c1d311486946b2b6f612c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; KTfwd::population_sfs </td>
          <td>(</td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae48c3a9aea8e34355c01c986ba534d26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::push_at_end </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy Works via push_back instead of insert, so there is no return value. </p>
<p>A common use of this policy will be when a mutation model always gives rise to a gamete that does not currently exist in the population, such as the infinitely-many sites model of mutations. For such models, it is sufficient to simply append the new gamete to the existing vector.</p>
<p>Note: it is silly to pass ng to this function with ng.n = 0.</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5275d35cfd958887603103fa8ad9ed80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type2, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_reader , typename istreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">vector_type2&lt; vector_type&lt; gamete_type, vector_type_allocator &gt;, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istreamtype &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the metapopulation back from a binary-format file Read the metapopulation back from a binary-format file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gametes</td><td>Destination for the gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for the mutations </td></tr>
    <tr><td class="paramname">mr</td><td>A function object to read in the mutation information. Takes an istreamtype as argument. Must be provided by library user. </td></tr>
    <tr><td class="paramname">in</td><td>Input stream. Must support .read() in a manner similar to std::istream types. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a27">migsel_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a54c16f28e2e1e883e7cff3f0aa8a004e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type2, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_reader &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">vector_type2&lt; vector_type&lt; gamete_type, vector_type_allocator &gt;, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>gzin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the metapopulation back from a compressed binary-format file Read the metapopulation back from a compressed binary-format file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gametes</td><td>Destination for the gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for the mutations </td></tr>
    <tr><td class="paramname">mr</td><td>A function object to read in the mutation information. Takes an istreamtype as argument. Must be provided by library user. </td></tr>
    <tr><td class="paramname">gzin</td><td>A gzFile (from zlib) opened for reading. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0eab931b65ce0864ed1ecf5a4d111b95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename metapop_vector_type_allocator , template&lt; typename, typename &gt; class metapop_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type , typename istreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">metapop_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vv_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader_type &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istreamtype &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the metapopulation back from a binary-format file for individual-based simulations Read the metapopulation back from a binary-format file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metapop</td><td>Destination for the gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for the mutations </td></tr>
    <tr><td class="paramname">diploids</td><td>Destination for the diploids </td></tr>
    <tr><td class="paramname">mr</td><td>A function object to read in the mutation information. Takes an istreamtype as argument. Must be provided by library user. </td></tr>
    <tr><td class="paramname">in</td><td>Input stream. Must support .read() in a manner similar to std::istream types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a005e06cb708cb010eaed381cadaee2c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename metapop_vector_type_allocator , template&lt; typename, typename &gt; class metapop_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_reader_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">metapop_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vv_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader_type &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>gzin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the metapopulation back from a compressed binary-format file for individual-based simulations Read the metapopulation back from a compressed binary-format file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metapop</td><td>Destination for the gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for the mutations </td></tr>
    <tr><td class="paramname">diploids</td><td>Destination for the diploids </td></tr>
    <tr><td class="paramname">mr</td><td>A function object to read in the mutation information. Takes an istreamtype as argument. Must be provided by library user. </td></tr>
    <tr><td class="paramname">gzin</td><td>An opened gzFile from zlib. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa86f256af3adb31cc09ad797b3d76c6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_reader , typename istreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_pop </td>
          <td>(</td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istreamtype &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d7/dd8/diploid_binaryIO_8cc-example.html#a28">diploid_binaryIO.cc</a>, <a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a26">diploid_binaryIO_ind.cc</a>, <a class="el" href="../../d3/da0/diploid_gzbinaryIO_8cc-example.html#a28">diploid_gzbinaryIO.cc</a>, and <a class="el" href="../../d6/d1e/diploid_gzbinaryIO_ind_8cc-example.html#a26">diploid_gzbinaryIO_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a51661a15c5305410ac8e9ae862ad3f0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_reader_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_pop </td>
          <td>(</td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader_type &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>gzin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b7584c8678ddbc46067710415cdd9e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_reader_type , typename istreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::read_binary_pop </td>
          <td>(</td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_reader_type &amp;&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istreamtype &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the population back from a binary-format file for individual-based simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gametes</td><td>Destination for the gametes </td></tr>
    <tr><td class="paramname">mutations</td><td>Destination for the mutations </td></tr>
    <tr><td class="paramname">diploids</td><td>Destination for the diploids </td></tr>
    <tr><td class="paramname">mr</td><td>A function object to read in the mutation information. Takes an istreamtype as argument. Must be provided by library user. </td></tr>
    <tr><td class="paramname">in</td><td>Input stream. Must support .read() in a manner similar to std::istream types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41bccb4fd1108616d626e371c3cf83c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename map_function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned KTfwd::recombine </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>littler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map_function &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d81/diploid_8cc-example.html#a17">diploid.cc</a>, <a class="el" href="../../d7/dd8/diploid_binaryIO_8cc-example.html#a26">diploid_binaryIO.cc</a>, <a class="el" href="../../d7/d24/diploid_fixed_sh_8cc-example.html#a12">diploid_fixed_sh.cc</a>, <a class="el" href="../../d3/da0/diploid_gzbinaryIO_8cc-example.html#a26">diploid_gzbinaryIO.cc</a>, <a class="el" href="../../dd/da1/diploid_twopop_mig_8cc-example.html#a20">diploid_twopop_mig.cc</a>, <a class="el" href="../../d3/d0a/RHH_8cc-example.html#a15">RHH.cc</a>, and <a class="el" href="../../dc/d1a/TFL2013_8cc-example.html#a19">TFL2013.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8a46b107991548a40821e132496c1693"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename recombination_map , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned KTfwd::recombine_gametes </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>littler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; typename iterator_type::value_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_map &amp;&#160;</td>
          <td class="paramname"><em>mf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recombination for individual-based forward simulations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">littler</td><td>The probability of a single recombination event between g1 and g2 </td></tr>
    <tr><td class="paramname">gametes</td><td>Pointer to the list of gametes in the population </td></tr>
    <tr><td class="paramname">g1</td><td>Iterator to the first gamete involved in the recombination event </td></tr>
    <tr><td class="paramname">g2</td><td>Iterator to the second gamete involved in the recombination event </td></tr>
    <tr><td class="paramname">mf</td><td>Recombination policy which generates crossover positions </td></tr>
    <tr><td class="paramname">gpolicy</td><td>Policy determining how new gametes are added to population</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>g1 and g2 will be changed </dd>
<dd>
The type of g1 and g2 is gamete_list_type&lt;gamete_type,list_type_allocator &gt;::iterator </dd>
<dd>
The return value may be 0 even if littler is large. The code recognizes when crossovers could not modify the gametes, and the function returns when such cases are found </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossovers that happened between g1 and g2 (which is Poisson with mean littler) </dd></dl>

</div>
</div>
<a class="anchor" id="a84e666ea27d38bdfc539ffd23653eaa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_fixed_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; mutation_type, vector_type_allocator1 &gt; *&#160;</td>
          <td class="paramname"><em>fixations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; unsigned, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>fixation_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>generation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d81/diploid_8cc-example.html#a14">diploid.cc</a>, <a class="el" href="../../d7/dd8/diploid_binaryIO_8cc-example.html#a23">diploid_binaryIO.cc</a>, <a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a24">diploid_binaryIO_ind.cc</a>, <a class="el" href="../../d7/d24/diploid_fixed_sh_8cc-example.html#a9">diploid_fixed_sh.cc</a>, <a class="el" href="../../df/df6/diploid_fixed_sh_ind_8cc-example.html#a11">diploid_fixed_sh_ind.cc</a>, <a class="el" href="../../d3/da0/diploid_gzbinaryIO_8cc-example.html#a23">diploid_gzbinaryIO.cc</a>, <a class="el" href="../../d6/d1e/diploid_gzbinaryIO_ind_8cc-example.html#a24">diploid_gzbinaryIO_ind.cc</a>, <a class="el" href="../../db/de9/diploid_ind_8cc-example.html#a15">diploid_ind.cc</a>, <a class="el" href="../../dd/da1/diploid_twopop_mig_8cc-example.html#a17">diploid_twopop_mig.cc</a>, <a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a24">migsel_ind.cc</a>, <a class="el" href="../../d3/d0a/RHH_8cc-example.html#a12">RHH.cc</a>, and <a class="el" href="../../dc/d1a/TFL2013_8cc-example.html#a15">TFL2013.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adbc0bd4b96e6164ec339823c85de235e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename vector_type_allocator1 , typename vector_type_allocator2 , typename list_type_allocator , template&lt; typename, typename &gt; class vector_type, template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_fixed_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; mutation_type, vector_type_allocator1 &gt; *&#160;</td>
          <td class="paramname"><em>fixations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; unsigned, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>fixation_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_lookup_table *&#160;</td>
          <td class="paramname"><em>lookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>generation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a86a4fcecb15c101816ccdd15eefd6a1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad73eeda26047df89b8ea303c0d8a6b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_lookup_table &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::remove_lost </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_lookup_table *&#160;</td>
          <td class="paramname"><em>lookup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a946efaa4a6095f4f2aadda44a809a477"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename diploid_fitness_function , typename mutation_removal_policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d81/diploid_8cc-example.html#a11">diploid.cc</a>, <a class="el" href="../../d7/dd8/diploid_binaryIO_8cc-example.html#a20">diploid_binaryIO.cc</a>, <a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a20">diploid_binaryIO_ind.cc</a>, <a class="el" href="../../d7/d24/diploid_fixed_sh_8cc-example.html#a6">diploid_fixed_sh.cc</a>, <a class="el" href="../../df/df6/diploid_fixed_sh_ind_8cc-example.html#a7">diploid_fixed_sh_ind.cc</a>, <a class="el" href="../../d3/da0/diploid_gzbinaryIO_8cc-example.html#a20">diploid_gzbinaryIO.cc</a>, <a class="el" href="../../d6/d1e/diploid_gzbinaryIO_ind_8cc-example.html#a20">diploid_gzbinaryIO_ind.cc</a>, <a class="el" href="../../db/de9/diploid_ind_8cc-example.html#a11">diploid_ind.cc</a>, <a class="el" href="../../dd/da1/diploid_twopop_mig_8cc-example.html#a15">diploid_twopop_mig.cc</a>, <a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a21">migsel_ind.cc</a>, <a class="el" href="../../de/d58/pfix_8cc-example.html#a10">pfix.cc</a>, <a class="el" href="../../d3/d0a/RHH_8cc-example.html#a9">RHH.cc</a>, and <a class="el" href="../../dc/d1a/TFL2013_8cc-example.html#a13">TFL2013.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ade94ef65f07d1e664a19f20d2582728d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; locus_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model_container &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy_container &amp;&#160;</td>
          <td class="paramname"><em>rec_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>r_between_loci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a761a0438d183384e5e8b49e89121d21e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a04a19140f729a493851685202d73c606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename diploid_fitness_function , typename mutation_removal_policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wright-Fisher sampling of a single population of changing size Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness where population size changes from twoN_curr to twoN_next. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">gametes</td><td>Vector of gametes in the population </td></tr>
    <tr><td class="paramname">twoN_curr</td><td>Twice the diploid population size in the current generation </td></tr>
    <tr><td class="paramname">twoN_next</td><td>Twice the diploid population size in the next generation </td></tr>
    <tr><td class="paramname">ff</td><td>A fitness function taking two gamete_type as arguments </td></tr>
    <tr><td class="paramname">mp</td><td>A policy determining how mutations are removed from populatio after sampling. See <a class="el" href="../../d4/de8/structKTfwd_1_1mutation__remover.html" title="Policy determining how mutations are removed from gametes after sampling Policy determining how mutat...">KTfwd::mutation_remover</a> for example </td></tr>
    <tr><td class="paramname">f</td><td>Probability that a mating is an inbreeding event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa6b4b4c12ce030e4bd1f32a0cd95b3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename glist_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename locus_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model_container , typename recombination_policy_container , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class glist_vector_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class locus_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glist_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, glist_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; locus_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, locus_vector_type_allocator &gt;, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_model_container &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy_container &amp;&#160;</td>
          <td class="paramname"><em>rec_policies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>r_between_loci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad49f95a9fb81ad6e735437d956f59ddb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>twoNs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>metapopsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a225d8aeed18091cd7ced5890f56afe52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function &amp;&#160;</td>
          <td class="paramname"><em>ff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5647d600600d1e7c8254714c1b35d47f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>twoNs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>twoNs_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>metapopsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wright-Fisher sampling of a metapopulation population of constant size with inbreeding Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness under constant population size for a metapopulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">metapop</td><td>Vector vector of gametes in the metapopulation </td></tr>
    <tr><td class="paramname">twoNs</td><td>Array of 2N for each deme in the current generation </td></tr>
    <tr><td class="paramname">twoNs_next</td><td>Array of 2N for each deme in the next generation </td></tr>
    <tr><td class="paramname">metapopsize</td><td>Sum of values in [twoNs,twoNs+metapop-&gt;size()) </td></tr>
    <tr><td class="paramname">ffs</td><td>A vector fitness functions taking two gamete_type as arguments. Each deme can have a different fitness function </td></tr>
    <tr><td class="paramname">mp</td><td>A policy determining how mutations are removed from populatio after sampling. See <a class="el" href="../../d4/de8/structKTfwd_1_1mutation__remover.html" title="Policy determining how mutations are removed from gametes after sampling Policy determining how mutat...">KTfwd::mutation_remover</a> for example </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa30567b5fe3c278ae72a9caaa744aaa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>twoNs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>metapopsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wright-Fisher sampling of a metapopulation population of changing size Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness under constant population size for a metapopulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">metapop</td><td>Vector vector of gametes in the metapopulation </td></tr>
    <tr><td class="paramname">twoNs</td><td>Array of 2N for each deme in the current generation </td></tr>
    <tr><td class="paramname">metapopsize</td><td>Sum of values in [twoNs,twoNs+metapop-&gt;size()) </td></tr>
    <tr><td class="paramname">ffs</td><td>A vector fitness functions taking two gamete_type as arguments. Each deme can have a different fitness function </td></tr>
    <tr><td class="paramname">mp</td><td>A policy determining how mutations are removed from populatio after sampling. See <a class="el" href="../../d4/de8/structKTfwd_1_1mutation__remover.html" title="Policy determining how mutations are removed from gametes after sampling Policy determining how mutat...">KTfwd::mutation_remover</a> for example </td></tr>
    <tr><td class="paramname">fs</td><td>An array of inbreeding probabilities for each deme. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf1d8fa7c50cd8dadcceef879b13a2c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename metapop_gamete_vector_type_allocator , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_gamete_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metapop_gamete_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_gamete_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metapop_diploid_vector_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const migration_policy &amp;&#160;</td>
          <td class="paramname"><em>mig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>f</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adc37b4ba70df5adbced155f80d656029"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator1 , typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type1, template&lt; typename, typename &gt; class vector_type2, typename diploid_fitness_function_container , typename mutation_removal_policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type2&lt; vector_type1&lt; gamete_type, vector_type_allocator1 &gt;, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>twoNs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>twoNs_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>metapopsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wright-Fisher sampling of a metapopulation population of changing size with inbreeding Performs multinomial sampling of gametes proportional to marginal fitness divided by population mean fitness under constant population size for a metapopulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">metapop</td><td>Vector vector of gametes in the metapopulation </td></tr>
    <tr><td class="paramname">twoNs</td><td>Array of 2N for each deme in the current generation </td></tr>
    <tr><td class="paramname">twoNs_next</td><td>Array of 2N for each deme in the next generation </td></tr>
    <tr><td class="paramname">metapopsize</td><td>Sum of values in [twoNs,twoNs+metapop-&gt;size()) </td></tr>
    <tr><td class="paramname">ffs</td><td>A vector fitness functions taking two gamete_type as arguments. Each deme can have a different fitness function </td></tr>
    <tr><td class="paramname">mp</td><td>A policy determining how mutations are removed from populatio after sampling. See <a class="el" href="../../d4/de8/structKTfwd_1_1mutation__remover.html" title="Policy determining how mutations are removed from gametes after sampling Policy determining how mutat...">KTfwd::mutation_remover</a> for example </td></tr>
    <tr><td class="paramname">fs</td><td>An array of inbreeding probabilities for each deme. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d97cd41a47a5e01dd034b94e16f49f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename metapop_gamete_vector_type_allocator , typename metapop_diploid_vector_type_allocator , typename gamete_list_type_allocator , typename mutation_list_type_allocator , typename diploid_vector_type_allocator , typename diploid_fitness_function_container , typename mutation_removal_policy , typename mutation_model , typename recombination_policy , typename migration_policy , typename mutation_insertion_policy , typename gamete_insertion_policy , template&lt; typename, typename &gt; class gamete_list_type, template&lt; typename, typename &gt; class mutation_list_type, template&lt; typename, typename &gt; class diploid_vector_type, template&lt; typename, typename &gt; class metapop_gamete_vector_type, template&lt; typename, typename &gt; class metapop_diploid_vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KTfwd::sample_diploid </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metapop_gamete_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_gamete_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metapop_diploid_vector_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, diploid_vector_type_allocator &gt;, metapop_diploid_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; typename gamete_type::mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>N_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>N_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d35/structmutation__model.html">mutation_model</a> &amp;&#160;</td>
          <td class="paramname"><em>mmodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const recombination_policy &amp;&#160;</td>
          <td class="paramname"><em>rec_pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>mpolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_insertion_policy &amp;&#160;</td>
          <td class="paramname"><em>gpolicy_mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_fitness_function_container &amp;&#160;</td>
          <td class="paramname"><em>ffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const migration_policy &amp;&#160;</td>
          <td class="paramname"><em>mig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>f</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evolve a metapopulation where demes may be changing size. For individual-based sims. Evolve a metapopulation where demes may be changing size. For individual-based sims. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>GSL random number generator </td></tr>
    <tr><td class="paramname">metapop</td><td>Pointer to vector of lists of gametes. </td></tr>
    <tr><td class="paramname">diploids</td><td>Pointer to the vector of vectors of parents from which we sample offspring </td></tr>
    <tr><td class="paramname">mutations</td><td>Pointer to list of mutations currently in population </td></tr>
    <tr><td class="paramname">N_curr</td><td>The current population sizes. There must be diploids-&gt;size() values in this array </td></tr>
    <tr><td class="paramname">N_next</td><td>The population sizes in the daughter generation. There must be diploids-&gt;size() values in this array </td></tr>
    <tr><td class="paramname">mu</td><td>The total mutation rate per gamete </td></tr>
    <tr><td class="paramname">mmodel</td><td>Mutation model policy </td></tr>
    <tr><td class="paramname">rec_pol</td><td>Recombination model policy </td></tr>
    <tr><td class="paramname">mpolicy</td><td>Policy determining how new mutations are added to the population </td></tr>
    <tr><td class="paramname">gpolicy_mut</td><td>Policy determining how new gametes are added to population after a mutation event </td></tr>
    <tr><td class="paramname">ffs</td><td>Container of fitness functions. One for each deme. </td></tr>
    <tr><td class="paramname">mp</td><td>Policy determining how to remove mutations from a diploid (e.g., removing fixed and/or lost mutations) </td></tr>
    <tr><td class="paramname">mig</td><td>Migration policy. This function/function object must take a single size_t (values 0 to metapop-&gt;size()-1). If no migration event occurs, the passed value is returned. Otherwise, a size_t representing the index of the deme from which the other parent comes (aka the migrant) is returned. </td></tr>
    <tr><td class="paramname">f</td><td>Probability that a mating is a selfing event. This is an array, with 1 f per deme.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>diploids will be updated to reflect the new diploid genotypes post-sampling (the descedants). Gametes will be changed by mutation, recombination, and sampling. Mutations will be changed by mutation and sampling. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The mean fitness of the parental generation </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a8a0218ff1f5dfc33268fd5243207b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; KTfwd::sample_sfs </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a105a292a1e5c591d64d14caf4062e2f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type , typename fitness_updating_policy_hom , typename fitness_updating_policy_het &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double KTfwd::site_dependent_fitness2 </td>
          <td>(</td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fitness_updating_policy_hom &amp;&#160;</td>
          <td class="paramname"><em>fpol_hom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fitness_updating_policy_het &amp;&#160;</td>
          <td class="paramname"><em>fpol_het</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>starting_fitness</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a91ac7525d84cfec32e3007029da92cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::uncheck </td>
          <td>(</td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b9cddaf4fdce8362637f127179cece8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , typename mutation_removal_policy , template&lt; typename, typename &gt; class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::update_gamete_list </td>
          <td>(</td>
          <td class="paramtype">vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>twoN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_removal_policy &amp;&#160;</td>
          <td class="paramname"><em>mrp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab010eee5104ec79dee18f987dfb4fdd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cT::iterator KTfwd::update_if_exists_insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>Useful when mutation models can give rise to gametes identical to those currently existing in the population. This will happen under finite-sites models.</p>
<p>If the new gamete (ng) is not found in gametes, then it is inserted at the end.</p>
<p>Otherwise, if it is found, the count of that gamete in the population is inremented by ng.n (the count of new gamete). </p>

</div>
</div>
<a class="anchor" id="ac4b12060a74d27f79272e437fce296af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename cT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::update_if_exists_push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cT *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An insertion policy. </p>
<p>Useful when mutation models can give rise to gametes identical to those currently existing in the population. This will happen under finite-sites models.</p>
<p>If the new gamete (ng) is not found in gametes, then it is inserted at the end.</p>
<p>Otherwise, if it is found, the count of that gamete in the population is inremented by ng.n (the count of new gamete).</p>
<p>Note: it is silly to pass ng to this function with ng.n = 0. </p>

</div>
</div>
<a class="anchor" id="a9beb352c8831c316862a18f3ebef4bbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_allocator_type , typename gamete_allocator_type2 , typename mutation_type , typename mutation_allocator_type , typename mutation_allocator_type2 , template&lt; typename, typename &gt; class source_gamete_container, template&lt; typename, typename &gt; class source_mut_container, template&lt; typename, typename &gt; class dest_gamete_container, template&lt; typename, typename &gt; class dest_mut_container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::valid_copy </td>
          <td>(</td>
          <td class="paramtype">const source_gamete_container&lt; gamete_type, gamete_allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_mut_container&lt; mutation_type, mutation_allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dest_gamete_container&lt; gamete_type, gamete_allocator_type2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gametes_destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dest_mut_container&lt; mutation_type, mutation_allocator_type2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutations_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you ever need to store (and later restore) the state of the population, a naive copy operation is not sufficient, because of all the pointers from the gametes container to elements of the mutations container. Use this function instead.</p>
<dl class="section note"><dt>Note</dt><dd>Only works for the case of unique mutation positions!!! </dd></dl>

</div>
</div>
<a class="anchor" id="abcc8a3fbd86d33660aa1ebca19be651f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename vector_type_allocator2 , template&lt; typename, typename &gt; class vector_type2, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_writer_type , typename ostreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::write_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">const vector_type2&lt; vector_type&lt; gamete_type, vector_type_allocator &gt;, vector_type_allocator2 &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_writer_type &amp;&#160;</td>
          <td class="paramname"><em>mw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostreamtype &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/d2e/migsel_ind_8cc-example.html#a26">migsel_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8edd4d917ccd2f2dc5dcf3529c8952c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename metapop_vector_type_allocator , template&lt; typename, typename &gt; class metapop_vector_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename diploid_vv_type_allocator , template&lt; typename, typename &gt; class diploid_vv_type, typename mutation_writer_type , typename ostreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::write_binary_metapop </td>
          <td>(</td>
          <td class="paramtype">const metapop_vector_type&lt; gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;, metapop_vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>metapop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_vv_type&lt; diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt;, diploid_vv_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_writer_type &amp;&#160;</td>
          <td class="paramname"><em>mw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostreamtype &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ec919521b4cb51ca9d7d8a7afabfdea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename vector_type_allocator , template&lt; typename, typename &gt; class vector_type, typename mutation_type , typename list_type_allocator , template&lt; typename, typename &gt; class list_type, typename mutation_writer , typename ostreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::write_binary_pop </td>
          <td>(</td>
          <td class="paramtype">const vector_type&lt; gamete_type, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_type&lt; mutation_type, list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_writer &amp;&#160;</td>
          <td class="paramname"><em>mw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostreamtype &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d7/dd8/diploid_binaryIO_8cc-example.html#a27">diploid_binaryIO.cc</a>, <a class="el" href="../../d6/d0a/diploid_binaryIO_ind_8cc-example.html#a25">diploid_binaryIO_ind.cc</a>, <a class="el" href="../../d3/da0/diploid_gzbinaryIO_8cc-example.html#a27">diploid_gzbinaryIO.cc</a>, and <a class="el" href="../../d6/d1e/diploid_gzbinaryIO_ind_8cc-example.html#a25">diploid_gzbinaryIO_ind.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9e38d4088239ecf2c9af7b11a13c3497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gamete_type , typename gamete_list_type_allocator , template&lt; typename, typename &gt; class gamete_list_type, typename mutation_type , typename mutation_list_type_allocator , template&lt; typename, typename &gt; class mutation_list_type, typename vector_type_allocator , template&lt; typename, typename &gt; class diploid_vector_type, typename mutation_writer_type , typename ostreamtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KTfwd::write_binary_pop </td>
          <td>(</td>
          <td class="paramtype">const gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_list_type&lt; mutation_type, mutation_list_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const diploid_vector_type&lt; std::pair&lt; typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator, typename gamete_list_type&lt; gamete_type, gamete_list_type_allocator &gt;::iterator &gt;, vector_type_allocator &gt; *&#160;</td>
          <td class="paramname"><em>diploids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_writer_type &amp;&#160;</td>
          <td class="paramname"><em>mw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostreamtype &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write population to binary-format file for individual-based simulations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gametes</td><td>The vector of lists gametes for each deme in metapop </td></tr>
    <tr><td class="paramname">mutations</td><td>The list of mutations </td></tr>
    <tr><td class="paramname">diploids</td><td>The vector of diploids </td></tr>
    <tr><td class="paramname">mw</td><td>A function object taking a mutation and an ostreamtype as arguments. Must be prov </td></tr>
    <tr><td class="paramname">buffer</td><td>An ouptut stream into which the population is written. This is the "return value" of the function. The stream must support a write() function akin to those found in the std::ostream classes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If is often useful for buffer to be of type std::ostringstream to allow writing of the buffered data to C-style file handles/pointers, in turn allowing file locking which speeds up performance on distributed file systems. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
